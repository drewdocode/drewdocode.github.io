var traverse=require("../index"),assert=require("assert");describe("json-schema-traverse",function(){function e(){r.push(Array.prototype.slice.call(arguments))}var r;beforeEach(function(){r=[]}),it("should traverse all keywords containing schemas recursively",function(){var t=require("./fixtures/schema").schema,s=require("./fixtures/schema").expectedCalls;traverse(t,e),assert.deepStrictEqual(r,s)}),describe("allKeys option",function(){var t={someObject:{minimum:1,maximum:2}};it("should traverse objects with allKeys: true option",function(){var s=[[t,"",t,void 0,void 0,void 0,void 0],[t.someObject,"/someObject",t,"","someObject",t,void 0]];traverse(t,{allKeys:!0},e),assert.deepStrictEqual(r,s)}),it("should NOT traverse objects with allKeys: false option",function(){var s=[[t,"",t,void 0,void 0,void 0,void 0]];traverse(t,{allKeys:!1},e),assert.deepStrictEqual(r,s)}),it("should NOT traverse objects without allKeys option",function(){var s=[[t,"",t,void 0,void 0,void 0,void 0]];traverse(t,e),assert.deepStrictEqual(r,s)}),it("should NOT travers objects in standard keywords which value is not a schema",function(){var t={const:{foo:"bar"},enum:["a","b"],required:["foo"],another:{},patternProperties:{},dependencies:!0,properties:{smaller:{type:"number"},larger:{type:"number",minimum:{$data:"1/smaller"}}}},s=[[t,"",t,void 0,void 0,void 0,void 0],[t.another,"/another",t,"","another",t,void 0],[t.properties.smaller,"/properties/smaller",t,"","properties",t,"smaller"],[t.properties.larger,"/properties/larger",t,"","properties",t,"larger"]];traverse(t,{allKeys:!0},e),assert.deepStrictEqual(r,s)})})});