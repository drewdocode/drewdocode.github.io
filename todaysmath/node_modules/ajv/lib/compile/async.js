function compileAsync(e,n,r){function o(e){var n=e.$schema;return n&&!i.getSchema(n)?compileAsync.call(i,{$ref:n},!0):Promise.resolve()}function t(e){try{return i._compile(e)}catch(r){if(r instanceof MissingRefError)return function(r){function c(){delete i._loadingSchemas[s]}function a(e){return i._refs[e]||i._schemas[e]}var s=r.missingSchema;if(a(s))throw new Error("Schema "+s+" is loaded but "+r.missingRef+" cannot be resolved");var u=i._loadingSchemas[s];return u||(u=i._loadingSchemas[s]=i._opts.loadSchema(s),u.then(c,c)),u.then(function(e){if(!a(s))return o(e).then(function(){a(s)||i.addSchema(e,s,void 0,n)})}).then(function(){return t(e)})}(r);throw r}}var i=this;if("function"!=typeof this._opts.loadSchema)throw new Error("options.loadSchema should be a function");"function"==typeof n&&(r=n,n=void 0);var c=o(e).then(function(){var r=i._addSchema(e,void 0,n);return r.validate||t(r)});return r&&c.then(function(e){r(null,e)},r),c}var MissingRefError=require("./error_classes").MissingRef;module.exports=compileAsync;